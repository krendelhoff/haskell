import           Cont

sumIt :: Cont [r] Integer
sumIt = do
  a <- return 3
--  b <- Cont $ \c -> "STOP" -- результат предыдущего вычисления не взят
  b <- Cont $ \c -> c 5 ++ c 4
  return $ a + b
--
--
--
--
-- понятно почему в конце только определяется тип - передается то в исходное вычисление действительно (Int -> String), т.к на выходе там String
-- (Int -> String) -> String, начиная с \a идет Int -> String
-- (\c -> c 3) >>= (\a -> (\c -> "STOP") >>= (\b -> return $ a + b))
--(\c -> c 3) >>= (\a -> (\c -> c 5) >>= (\b -> return $ a + b))
--(\c -> c 3) >>= (\a -> (\c -> c 5 ++ c 4) >>= (\b -> return $ a + b))
-- теперь понятно
-- \a закидывается в левый c
-- по сути вычисление идет как бы с обратной стороны, с конца всё закидывается справа налево, тут это видно ( в рамках одного bind, конечно)
-- \b закидывается в срединный c
-- непривычно относительно привычных монадических операций
--
--
  {-(\c -> c 3) >>= (\a -> (\c -> "STOP") >>= (\b -> return $ a + b)) -->
  (\c -> "STOP") >>= (\b -> return $ 3 + b)) ---> \c -> "STOP" -}
  -- ПОДОЙДЕТ ЛЮБАЯ ФУНКЦИЯ Int -> String, не только show, и тут это без логики, просто из соображения типов
  -- runCont sumIt (const "bib" :: Integer -> String)
